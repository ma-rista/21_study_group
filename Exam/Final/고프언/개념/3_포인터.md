# Pointer

## ✅ 개념
- 자료가 저장되는 기억장치의 기억주소를 가리키는 **지시자**<br>
- 다른 기억장소의 자료를 참조하는데 사용되는 데이터<br>

## 🤷‍♂️ 사용 이유
- 모든 변수는 Buffer를 할당받아 사용,
- 변수의 저장과 참조는 변수가 저장될 or 저장된 주소를 알아야 가능<br>
- 컴퓨터는 변수를 참조할 때 그 변수가 저장되어있는 주소를 먼저 찾아내고, 그 주소를 가리키는 내용을 참조하게 됨<br>
- 변수의 주소를 저장 사용하기 위해 포인터를 사용
> #### [장점]<br> 
> 1. 간결, 효율적인 표현과 처리 가능<br>
> 2. 더 빠른 기계어 코드를 생성 가능<br>
> 3. 복잡한 자료구조(배열, 구조체 등)와 함수의 쉬운 접근이 가능<br>
> 4. 포인터를 사용하지 않았을 때 코드로 표현할 수 없는 경우 발생

```c
// 변수의 메모리 주소 구하기 -> 실행할 때마다 달라짐!
#include <stdio.h>

int main()
{
    int num1 = 10;
    
    printf("%p\n", &num1);
    
    return 0;
}
```

## 🙋‍♀️ 포인터 선언
`저장할 공간의 자료형 *변수명(포인터이름);`<br>
`포인터 = &변수;`<br>
➕ 포인터 선언지 *(asterisk)의 위치에 따른 차이 없다

![포인터 구조](https://dojang.io/pluginfile.php/338/mod_page/content/23/unit34-3.png)<br><br><br>

## 역참조
- 포인터 변수 안에 저장된 주소로 접근해서 주소 안의 값을 확인할 때는 포인터 변수 형식으로 할 수 있다.<br>
- 포인터 변수에는 value가 아닌 메모리 주소가 저장되어 있다. 이때 메모리 주소가 있는 곳으로 이동해서 값을 가져오고 싶다면 **역참조**인 `*`을 사용

```c
// 역참조 연산자를 이용하여 값(value) 접근
#include <stdio.h>

int main()
{
    int *numPtr;
    int num1 = 10;
    
    numPtr = &num1;
    
    printf("%d\n", *numPtr);	// num1의 값인 10이 출력
    // 역참조 연산자로 num1의 메모리 주소에 접근하여 값(value)을 가져옴
    
    return 0;
}
```
> 포인터 선언시 '*'는 **이 변수가 포인터다!!** 의미<br>
> 포인터 사용시 '*'는 **포인터의 메모리 주소를 역참조하겠다!!!** 의미<br>

## 역참조<br>
- 포인터 변숫에는 값(value)가 아닌 메모리 주소가 저장되어 있다.<br>
- 이때 메모리 주소가 있는 곳으로 이동해서 값을 가져오고 싶으면<br>
- 역참조(dereference) 연산자인 `*`을 사용하면 된다.
```c
// 역참조 연산자를 이용하여 값(value) 접근
#include <stdio.h>

int main()
{
    int *numPtr;
    int num1 = 10;
    
    numPtr = &num1;
    
    printf("%d\n", *numPtr);	// num1의 값인 10이 출력
    // 역참조 연산자로 num1의 메모리 주소에 접근하여 값(value)을 가져옴
    
    return 0;
}
```
```c
// 역참조 연산자를 이용하여 값(value)을 저장
#include <stdio.h>

int main()
{
    int *numPtr;
    int num1 = 10;
    printf("%d\n", num1);
    
    numPtr = &num1;
    *numPtr = 20;	// 역참조 연산자로 메모리 주소에 접근하여 20을 저장
    
    printf("%d\n", *numPtr);	// 역참조 연산자로 메모리 주소에 접근하여 값 가져옴
    printf("%d\n", num1);	// 실제 num1의 값(value)도 바뀜
    
    return 0;
}
```
- 포인터 선언시 `*`는 **"이 변수가 포인터다!"** 의미<br>
- 포인터 사용시 `*`는 **"포인터의 메모리 주소를 역참조하겠다!"** 라는 의미<br><br><br>
## 포인터 자료형<br>
- 포인터도 다양한 포인터 자료형이 있다.<br>
- C언어 사용할 수 있는 모든 자료형은 포인터로 만들 수 있다.<br>
### 🤷‍♀️WHY?<br>
- 포인터 저장되는 메모리 주소값은 정수형으로 동일<br>
- 선언하는 자료형에 따라 메모리 접근 방법이 달라지기 때문에 자료형마다 포인터 선언하는 것
![포인터 자료형](https://media.vlpt.us/images/kimdukbae/post/dc6c3d0f-6cf4-4128-8185-cd4125adfb80/image.png)

## void 포인터
- 자료형이 정해지지 않은 포인터<br>
- `void *포인터이름;` // void 포인터 선언
-  기본적으로 C언어안에서 자료형이 다른 포인터끼리 메모리 주소를 저장하면 오류가 발생<br>
- void 포인터는 자료형이 정해지지 않으므로 어떠한 포인터 자료형이든 모두 저장 가능<br>
- 반대의 경우 다양한 자료형으로 된 포인터에도 void포인터를 저장 가능<br>
- void 포인터를 '범용 포인터'라고 한다.
```c
// void 포인터
#include <stdio.h>

int main()
{
    int num1 = 10;
    char c1 = 'a';
    int *numPtr1 = &num1;
    char *cPtr1 = &c1;
    
    void *ptr;	// void 포인터 선언
    
    // 포인터 자료형이 달라도 오류 X
    ptr = numPtr1;	// void 포인터에 int 포인터 저장
    prt = cPtr1;	// void 포인터에 char 포인터 저장
    
    // 포인터 자료형이 달라도 컴파일 경고가 발생하지 않음
    numPtr1 = ptr;
    cPtr1 = ptr;
    
    return 0;
}
```
<br>
<br>

## 이중 포인터<br>
- 포인터의 포인터<br>
`자료형 **포인터이름;` //  이중 포인터 선언<br>
- 포인터 선언할때 `*`을 2번 사용하여 선언<br>
- 포인터의 메모리 주소는 일반 포인터에 저장 못 함<br>
- 이중 포인터를 사용해야 되는데, **int **numPtr2;`**`처럼 이중포인터에 저장<br>
- ➕ 포인터 선언시 `*`의 개수에 따라 삼중, 사중 포인터 그 이상도 만들 수 있다.<br>
- 역참조 연산자 사용시 `*`를 3, 4 그 이상 사용 가능<br><br>
![포인터 자료형](https://media.vlpt.us/images/kimdukbae/post/67d6bb9c-4e20-4ead-aebd-2ce10d4ae337/image.png)